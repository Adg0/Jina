#pragma version 6

txn OnCompletion
int NoOp
==
bnz handle_noop

txn OnCompletion
int OptIn
==
bnz handle_optin

txn OnCompletion
int CloseOut
==
bnz handle_closeout

txn OnCompletion
int UpdateApplication
==
bnz creator_only

txn OnCompletion
int DeleteApplication
==
bnz creator_only

// Unexpected OnCompletion value. Should be unreachable.
err

// Handle NoOp
handle_noop:

	// Handle borrowing
	// Handle updating collateral
	// Handle lending
	// Handle repay
	// Handle claim
	// Handle return ASA admin rights
	// Handle liquidate

	txna ApplicationArgs 0
	store 10
	load 10
	byte "borrow"
	==
	bnz borrow
	load 10
	byte "update_borrow"
	==
	bnz borrower_update
	load 10
	byte "lend"
	==
	bnz lender
	load 10
	byte "repay"
	==
	bnz repay
	load 10
	byte "claim"
	==
	bnz claim
	load 10
	byte "create"
	==
	bnz create
	load 10
	byte "return"
	==
	bnz return_asset
	load 10
	byte "liquidated"
	==
	bnz liquidated
	// is invalid arg
	err

// Handle borrowing
	// Check borrower
		// Check if collateral is allowed (asset adimns are this protocol)
		// Check if loan + new loan is < 90% of collateral
	// Update loan state
		// Add new loan + previous loan to loan state
		// Update collateral amount
	// Update liquidity state (similar to claim)
		// Subtract from allowed loan amount of lender, the exact amount lender sent
	// Send JUSD to lender (reverse but simiilar to claim)
		// Send 1:1 JUSD for lenders that sent USDCa
// Handle updating borrow (update collateral)
	// Similar to repay
	// Check if loan < 90% of collateral after reducing the collateral amount
	// Update collateral amount

// NOTE:
	// Lenders can be on the look-out to liquidate a collateralized NFT. And take the NFT for themselves.
	// Since liquidator clawback is `ON` the moment someone borrows, that gives lenders a chance to liquidate the asset.
	// Would be cool if liquidation can be done using JUSD. 
		// And it should be possible. 
		// Only issue to look for is the pegging not diverging.

borrow:
	callsub is_borrow_possible
	assert
	txn NumAccounts // number of lenders
	store 0 // lender
	txn Sender
	global CurrentApplicationID
	dup2
	byte "xids" // as collateral_assets
	app_local_get_ex
	assert
	int 0 // pointer to first asset in collateral_asset (increment by 8 for next asset)
	extract_uint64
	store 1 // collateral_assetID
	byte "camt"
	app_local_get_ex
	assert
	int 0 // pointer to first asset in collateral_asset (increment by 8 for next asset)
	extract_uint64
	store 2 // collateral_amount
	b iou_to_lenders

// loop to check next lender
iou_to_lenders:
	// build axfer transaction:
	// send jUSD to loan providers in accounts array
	load 0 // lender
	int 0
	==
	bnz update_borrower_local_state

	// check if lender allows collateral of borrower
	load 0 // lender number (accounts array)
	gtxns Sender
	global CurrentApplicationID
	byte "xids" // as allowed_assets
	app_local_get_ex
	assert
	store 3 // allowed_assets in lender's local state
	callsub check_asset_is_allowed

	itxn_begin // replace with itxn_next for future (version 6)
	int 0
	itxn_field Fee
	int axfer
	itxn_field TypeEnum
	//Asset ID must be in the assets array
	global CurrentApplicationID
	byte "jusd"
	app_global_get_ex
	assert // jUSD
	itxn_field XferAsset

	load 0 // lender
	dup
	dup2
	gtxns XferAsset
	int 10458941 // USDCa
	==
	assert
	gtxns Sender // lender-x
	dup
	dup
	itxn_field AssetReceiver
	global CurrentApplicationID
	byte "aamt"
	app_local_get_ex
	assert
	// stack = [ allowed_amount, Sender, load 0, load 0 ]
	uncover 3
	gtxns AssetAmount
	dup
	int 3
	*
	int 100
	/
	+
	dup2
	>=
	assert
	dup
	cover 3
	-
	byte "aamt"
	swap
	app_local_put

	dup
	load 5 // requested loan amount
	+
	store 5 // requested loan amount
	itxn_field AssetAmount
	itxn_submit // remove on next update (version 6)
	int 1
	-
	store 0
	b iou_to_lenders

// loop to check next assetID in local state
check_asset_is_allowed:
	// value of key: "allowed_assets"
	load 1 // collateral_assetID of borrower
	load 3 // allowed_assets []byte
	load 4 // pointer
	extract_uint64 // error when pointer+8 is greater than allowed_assets's length (means asset not allowed)
	==
	int 8 // increment by 8; since it is a uint64
	load 4 // pointer
	+
	store 4 // update pointer to point to next uint64 in []byte
	bz check_asset_is_allowed
	int 0 // reset pointer to 0 for next lender
	store 4 // pointer
	retsub

update_borrower_local_state:
	// freeze borrower's asset
	txn Sender // borrower's account
	dup
	dup2
	itxn_begin
	int 0
	itxn_field Fee
	int afrz
	itxn_field TypeEnum
	//account to freeze
	itxn_field FreezeAssetAccount
	//asset to be frozen
	load 1 // collateral_assetID
	itxn_field FreezeAsset
	int 1 //set frozen status to true
	itxn_field FreezeAssetFrozen
	itxn_submit // this is an atomic inner transaction

	global CurrentApplicationID
	byte "lamt"
	app_local_get_ex
	bz new_borrow
	int 0
	extract_uint64
	load 5 // requested loan amount
	+
	dup
	store 6 // loan_amount
	byte "lamt"
	swap
	itob // change this value to BigEndian []uint64
	app_local_put
	b loan_health

new_borrow:
	// write new loan amount to borrower's local state
	pop
	byte "lamt"
	load 5 // requested loan amount
	dup
	store 6 // loan_amount
	itob // change this value to BigEndian []uint64
	app_local_put
	b loan_health

loan_health:
	// Logic that checks if its possible to take more loan
	load 6 // loan_amount
	txn Sender
	global CurrentApplicationID
	byte "camt"
	app_local_get_ex
	assert
	// TODO: Iterate and see if loan is healthy
	int 0
	extract_uint64
	// Oracle's price
	int 50000000 // price of asset
	*
	<=
	return

create:
	// For demo purpose
	txn NumAccounts
	int 1
	==
	bnz fund_dispenser

	// Optin to USDCa
	itxn_begin
	int 0
	dup
	itxn_field Fee
	itxn_field AssetAmount
	int axfer
	itxn_field TypeEnum
	int 10458941 // USDCa
	itxn_field XferAsset
	global CurrentApplicationAddress // itxn sender
	itxn_field AssetReceiver
	itxn_submit

	global CurrentApplicationID
	byte "jusd"
	app_global_get_ex
	bnz creator_only
	pop

	// Create jUSD (I-O-U asset)
	// Set liquidator as clawback admin for jUSD
	itxn_begin
	int 0
	itxn_field Fee
	int acfg
	itxn_field TypeEnum
	int 10458941 // USDCa
	dup
	asset_params_get AssetTotal
	assert
	itxn_field ConfigAssetTotal
	asset_params_get AssetDecimals
	assert
	itxn_field ConfigAssetDecimals
	byte "jUSD"
	itxn_field ConfigAssetUnitName
	byte "JUSD"
	itxn_field ConfigAssetName
	byte "https://"
	itxn_field ConfigAssetURL
	global CurrentApplicationAddress
	dup
	dup
	itxn_field ConfigAssetManager
	itxn_field ConfigAssetReserve
	itxn_field ConfigAssetFreeze
	global CurrentApplicationID
	byte "lqt"
	app_global_get_ex
	assert
	app_params_get AppAddress
	assert
	itxn_field ConfigAssetClawback
	itxn_submit
	byte "jusd"
	itxn CreatedAssetID // assetID of IOU token created
	app_global_put
	b creator_only

fund_dispenser:
	// Supply some amount for the dispenser
	// Make sure the account has Opted in for I-O-U asset
	itxn_begin
	int 1000000000000
	itxn_field AssetAmount
	int axfer
	itxn_field TypeEnum
	global CurrentApplicationID
	byte "jusd"
	app_global_get_ex
	assert
	itxn_field XferAsset
	txna Accounts 1
	itxn_field AssetReceiver
	itxn_submit
	b creator_only

handle_optin:
// Handle OptIn
	txn Sender
	byte "xids"
	int 0
	itob
	app_local_put
	int 1
	return
	//txn NumAppArgs
	//int 0
	//>
	//txna ApplicationArgs 0
	//byte "create"
	//==
	//bnz create
	//err

lender:
	txn Sender
	dup
	dup2
	byte "xids" // as allowed_assets
	txna ApplicationArgs 1
	app_local_put 
	byte "aamt"
	txna ApplicationArgs 2
	btoi
	// TODO: [indexer] check if user has specified amount, if not: set to max amount
	app_local_put
	byte "lsa"
	txna ApplicationArgs 3
	// TODO: [indexer] use this hash to find the right lsig file for signing this lender's txn by borrower
	app_local_put
	// input expiring time of offer
	byte "lvr"
	txna ApplicationArgs 4
	btoi
	app_local_put
	int 1
	return

borrower_update:
	callsub is_borrow_possible
	return

is_borrow_possible:
	txn Sender // same as [int 0] or [txn Accounts 0]
	dup
	byte "xids" // as collateral_assets
	txna ApplicationArgs 1
	// make sure the asset Can be frozen, clawedback
	dup
	cover 3
	app_local_put
	int 0
	extract_uint64 // collateral_assetID 0
	dup
	dup2
	asset_params_get AssetManager
	assert
	global CurrentApplicationAddress
	==
	assert
	asset_params_get AssetFreeze
	assert
	global CurrentApplicationAddress
	==
	assert
	asset_params_get AssetClawback
	assert
	global CurrentApplicationID
	byte "lqt"
	app_global_get_ex
	assert
	app_params_get AppAddress
	assert
	==
	assert
	swap
	byte "camt" // max_liquidate
	txna ApplicationArgs 2
	// check account has stated amount
	dup
	cover 3
	app_local_put
	int 0
	extract_uint64 // collateral_amount of collateral_ID 0
	txn Sender
	uncover 2
	asset_holding_get AssetBalance
	assert
	<=
	retsub

repay:
	txn Sender
	byte "lamt"
	txn GroupIndex
	int 1
	+
	dup
	dup
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert
	gtxns XferAsset
	int 10458941 // USDCa
	==
	assert
	gtxns AssetAmount
	txn Sender
	global CurrentApplicationID
	byte "lamt"
	app_local_get_ex
	assert
	int 0
	extract_uint64
	dup2
	>=
	// if, full loan is paid back unfreeze the asset
	bnz unfreeze_assets
	// else not full repay, just reduce the loan amount in local state
	swap
	-
	itob
	app_local_put
	int 1
	return

claim:
	txn GroupIndex
	int 1
	+
	dup
	dup
	gtxns AssetReceiver
	global CurrentApplicationAddress
	==
	assert
	gtxns XferAsset
	global CurrentApplicationID
	byte "jusd"
	app_global_get_ex
	assert // jUSD
	==
	assert
	itxn_begin
	gtxns AssetAmount
	dup
	itxn_field AssetAmount
	int 0
	itxn_field Fee
	int axfer
	itxn_field TypeEnum
	//Asset ID must be in the assets array
	int 10458941 // USDCa
	itxn_field XferAsset
	txn Sender
	dup
	itxn_field AssetReceiver
	itxn_submit
	global CurrentApplicationID
	byte "aamt"
	app_local_get_ex
	bnz reset_loan_amount
	int 1
	return

reset_loan_amount:
	+
	txn Sender
	byte "aamt"
	dig 2
	app_local_put
	int 1
	return

handle_closeout:
// Handle CloseOut
	txn Sender
	global CurrentApplicationID
	dup2
	byte "camt"
	app_local_get_ex
	bz closeout_app
	pop
	byte "lamt"
	app_local_get_ex
	bz unfreeze_assets
	// if there is still a borrowed amount, cannot close out
	err

unfreeze_assets:
	txn Sender
	dup
	global CurrentApplicationID
	byte "xids"
	app_local_get_ex
	assert
	dup
	cover 2
	load 4 // pointer
	extract_uint64
	dup2
	asset_holding_get AssetFrozen
	pop
	dig 1
	asset_params_get AssetFreeze
	pop
	global CurrentApplicationAddress
	==
	&&
	int 8
	load 4 // pointer
	+
	store 4
	dig 3
	len
	load 4
	>
	&&
	bnz unfreeze_assets
	//top of stack should be account to unfreeze
	itxn_begin
	int 0
	itxn_field Fee
	int afrz
	itxn_field TypeEnum
	//asset to unfreeze
	itxn_field FreezeAsset
	//account to unfreeze
	itxn_field FreezeAssetAccount
	int 0 //set frozen status to false
	itxn_field FreezeAssetFrozen
	itxn_submit
	// loop to unfreeze next asset
	// check if at end of byte (collateral_assets[]uint64)
	len
	load 4
	>
	bnz unfreeze_assets
	int 0
	store 4 // reset pointer
	txn Sender
	byte "lamt" // loan amount
	app_local_del
	int 1
	return

liquidated:
	txn Sender
	global CurrentApplicationID
	byte "lqt"
	app_global_get_ex
	assert
	app_params_get AppAddress
	assert
	==
	bnz unfreeze_assets
	err

closeout_app:
	txn Sender
	dup
	dup2
	dup2
	byte "xids" // participation assets
	app_local_del
	byte "aamt" // allowed borrow amount
	app_local_del
	byte "camt" // collateral amount
	app_local_del
	byte "lamt" // loan amount
	app_local_del
	byte "lvr" // last valid round of lending offer
	app_local_del
	byte "lsa" // hash identifier of logic sig account
	app_local_del
	int 1
	return

// Allowing updating or deleting the app. For creator only
creator_only:
	global CreatorAddress
	txn Sender
	==
	return

// Return Asset manager
return_asset:
	itxn_begin
	int 0
	itxn_field Fee
	int acfg
	itxn_field TypeEnum
	txn Assets 0
	dup
	itxn_field ConfigAsset
	asset_params_get AssetCreator
	assert
	dup
	txn Sender
	==
	assert
	dup
	dup2
	itxn_field ConfigAssetManager
	itxn_field ConfigAssetReserve
	itxn_field ConfigAssetFreeze
	itxn_field ConfigAssetClawback
	itxn_submit
	int 1
	return
