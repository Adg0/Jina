#pragma version 6

txn OnCompletion
int NoOp
==
bnz handle_noop

txn OnCompletion
int UpdateApplication
==
bnz creator_only

txn OnCompletion
int DeleteApplication
==
bnz creator_only

txn OnCompletion
int OptIn
==
bnz on_create

// Unexpected OnCompletion value. Should be unreachable.
err

handle_noop:
	txna Accounts 1 // address being liquidated (borrower address)
	global CurrentApplicationID
	byte "jina"
	app_global_get_ex
	assert // Jina applicationID
	dup2
	dup2
	byte "xids"
	app_local_get_ex
	assert
	store 0

	byte "camt"
	app_local_get_ex
	assert
	store 1

	byte "lamt"
	app_local_get_ex
	assert
	store 2

	b check_loan_health

//check if price of collateral is above 90% of loan
check_loan_health:
	load 2 // loan_amount []uint64
	int 0
	extract_uint64 // loan_amount of the collateral_assetID 0
	// TODO: oracle feature
	// using fetchMarketPrice[oracle_appID, collateral_assetID]price
	// app_get_price
	int 49000000 // demo-price of the collateral_assetID 0
	load 1 // collateral_amount []uint64
	int 0
	extract_uint64 // collateral_amount of the collateral_assetID 0
	// stack: [loanAmount, oracle_price, assetAmount]
	*
	// stack: [loanAmount, oracle_price*asssetAmount]
	dup
	store 5 // collateral price
	int 9
	*
	int 10
	/
	// stack: [loanAmount, (oracle_price*assetAmount)90%]
	> // is loanAmount > 90% of collateral ?
	// if loan is below 90%, the asset cannot be liquidated. Exit
	bz cannot_liqidate
	// if loan is above 90%, then continue liquidation

	// sell the collateral_assetID if its price is 5% more than loan locked. (a 10% penality is incured during liquidation: 5% for liquidator and 5% as insurance for jina)
	txn GroupIndex
	int 1
	+
	dup
	dup
	gtxns XferAsset // supplied USDCa in group txn
	int 10458941 // USDCa
	==
	assert
	global CurrentApplicationID
	byte "jina"
	app_global_get_ex
	assert // Jina applicationID
	app_params_get AppAddress
	assert
	swap
	gtxns AssetReceiver
	==
	assert
	gtxns AssetAmount // supplied USDCa in group txn
	load 5 // collateral price
	int 95
	*
	int 100
	/
	>= // USDCa supplied must be atleast 95% of collateral asset
	bnz clawback
	err

clawback:
	// clawback collateral asset
	itxn_begin
	int 0
	itxn_field Fee
	int axfer
	itxn_field TypeEnum
	txna Accounts 2 // address that will recieve the liquidation
	itxn_field AssetReceiver

	callsub is_asset_collateral
	txna Assets 0
	itxn_field XferAsset

	txna Accounts 1 // address being liquidated (borrower address)
	itxn_field AssetSender

	load 1 // collateral_amount []uint64
	load 4 // pointer
	extract_uint64 // assetAmount that will be clawed back
	itxn_field AssetAmount
	itxn_submit

	// TODO: Make app call to modify the loan state
	itxn_begin
	int 0
	itxn_field Fee
	int appl
	itxn_field TypeEnum
	global CurrentApplicationID
	byte "jina"
	app_global_get_ex
	assert
	itxn_field ApplicationID
	byte "liquidated"
	itxn_field ApplicationArgs
	txna Accounts 1
	itxn_field Accounts
	int NoOp
	itxn_field OnCompletion
	itxn_submit
	
	int 1
	return

is_asset_collateral:
	txna Assets 0
	load 0 // collateral_asset []uint64
	load 4 // pointer
	extract_uint64 // assetID that will be clawed back
	==
	load 4 // pointer
	int 8 // increment by 8; since it is a uint64
	+
	store 4 // update pointer to point to next uint64 in []byte
	bz is_asset_collateral
	load 4
	int 8 // decrement by 8; correcting the pointer head
	-
	store 4 // pointer
	retsub

// Allowing updating or deleting the app. For creator only
creator_only:
	global CreatorAddress
	txn Sender
	==
	assert
	txn NumAppArgs
	int 2
	>=
	bnz update_globals
	int 1
	return

update_globals:
	global CurrentApplicationID
	byte "jina" // jina applicationID
	app_global_get_ex
	assert
	txna ApplicationArgs 0
	btoi
	==
	global CurrentApplicationID
	byte "orc" // oracle applicationID
	app_global_get_ex
	assert
	txna ApplicationArgs 0
	btoi
	==
	&&
	bz on_create
	int 1
	return
	
on_create:
	byte "jina" // jina applicationID
	txna ApplicationArgs 0
	btoi
	app_global_put
	byte "orc" // oracle applicationID
	txna ApplicationArgs 1
	btoi
	app_global_put
	b creator_only

cannot_liqidate:
	err
